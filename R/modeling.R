#' Run adaptive elastic net to identify CREs regulating target genes
#'
#' This function will identify putative cis-regultory elements for each of the
#' inputted genes. It takes as input your Seurat object, the pseudocell matrices
#' generated by prepare_pseudocell_matrix, the list of genes that you wish to model,
#' and parameters for running the adaptive elastic net and parallelization.
#' Genes without genomic peaks (mitochondrial) in the provided Annotation
#' are excluded, and names are printed if verbose is TRUE. The function
#' returns information for each modeled gene as a list. Each gene's entry 
#' in this list is a list containing the following information:
#' the coefficient of determination calculated during the cross validation step
#' with the calculated lambda.min value, the trained model object, and a 
#' data frame with regulatory weights and standard errors for all
#' statistically significant CREs. Regulatory weights for non-significant CREs
#' are set to 0 for future analysis if desired.
#'
#' @param seurat A Seurat object
#' @param pseudocell_mat Pseudocell expression matrix to use
#' @param pseudocell_mat_peaks Pseudocell chromatin accessibility matrix to use
#' @param gene_list Names of genes to model
#' @param lambda2 Parameter for quadratic L2 penalty for regularization
#' @param gamma Positive constant for calculating adaptive weights
#' @param ci_cutoff Confidence interval cutoff used to determine whether an estimated non-zero coefficient should be kept
#' @param pval_cutoff As an alternative, p value cutoff to use in order to calculate ci_cutoff. E.g. p value of 0.5 corresponds to 95% CI.
#' @param set_nonsig_to_zero Boolean to determine whether non-significant coefficient estimates should be set to zero
#' @param max_distance Max distance from modeled gene's TSS to include CREs for building gene regulatory network model
#' @param train_fraction Fraction of pseudocells used for training during cross-validation step
#' @param num_bootstraps Number of bootstrap samples
#' @param bootstrap Boolean if set to false, will not perform bootstrapping
#' @param num_threads Number of threads to use for multithreading
#' @param globals_maxsize If running into RAM problems during multithreading, can use this parameter to set future.globals.maxSize if not done manually
#' @param verbose Boolean to determine whether to run silently
#' @param bs_seed Seed for reproducibility in determining bootstrap seeds, set to NULL if not needed
#' @param multi_seed Seed for reproducibility during multithreaded model training, set to NULL if not needed
#'
#' @return list of lists per modeled gene, containing modeling and CRE gene regulatory network information
#' @export
#'
run_peak_aen <- function(seurat,
                         pseudocell_mat,
                         pseudocell_mat_peaks,
                         gene_list,
                         lambda2 = 0.5,
                         gamma = 1,
                         ci_cutoff = 1.96,
                         pval_cutoff = NULL,
                         set_nonsig_to_zero = TRUE,
                         max_distance = 5e+05,
                         train_fraction = 0.8,
                         num_bootstraps = 1000,
                         bootstrap = TRUE,
                         num_threads = 16,
                         globals_maxsize = NULL,
                         verbose = TRUE,
                         bs_seed = 943126,
                         multi_seed = 6283408, ...) {
	require(gcdnet)
	require(future)
	require(future.apply)
	require(SeuratWrappers)
	require(Seurat)
	require(Signac)

	if (class(gene_list) == "list") {
		gene_list <- unlist(gene_list)
	}
  
  # remove genes that are not in the column names of pseudocell_mat
  # such cases can happen when gene_list is provided separately and contains
  # genes that are not the the expression matrix
  if (sum(gene_list %in% colnames(pseudocell_mat)) != length(gene_list)){
    print("The following genes were removed from gene_list because they do not exist in pseudocell_mat:")
    print(gene_list[!gene_list %in% colnames(pseudocell_mat)])
    gene_list = gene_list[gene_list %in% colnames(pseudocell_mat)]
  }
  

	# prepare peak gene key
	gene_coords <- Signac:::CollapseToLongestTranscript(Annotation(seurat))
	gene_list <- gene_list[which(gene_list %in% gene_coords$gene_name)]

	peak_matrix <- Signac:::DistanceToTSS(peaks = StringToGRanges(colnames(pseudocell_mat_peaks)),
                                          genes = gene_coords[which(gene_coords$gene_name %in% gene_list)],
                                          distance = max_distance)

	peak_matrix_list <- lapply(gene_list, function(x) {
	                           	peak_col <- peak_matrix[, x]
	                        	return(names(peak_col)[which(peak_col > 0)]) 
	                      	   })
	names(peak_matrix_list) <- gene_list

	# bootstrap setup
	num_bootstraps = num_bootstraps + 1 # last seed added for cross validation step
	if (!bootstrap) num_bootstraps = 2
	if (!(is.null(bs_seed))) set.seed(bs_seed)
	bootstrap_sequence_input_lists <- make_bootstrap_sequences(num_bootstraps, gene_list)

	# run aen
	peak_input_list <- lapply(gene_list, function(x) list(x, 
	                                                      as.data.frame(pseudocell_mat_peaks[, peak_matrix_list[[x]]]), 
	                                                      bootstrap_sequence_input_lists[[x]]))
	names(peak_input_list) <- gene_list

	# removing mitochondrial genes (no peaks to model)
	peak_input_list <- peak_input_list[which(unlist(lapply(peak_input_list, function(x) dim(x[[2]])[2])) > 1)]
	if (verbose && length(peak_input_list) != length(gene_list)) {
		print(paste0("Omitted (mitochondrial) genes with no genomic peaks: ",
					 gene_list[which(!(gene_list %in% names(peak_input_list)))]))
	} 
	if (num_threads > 1) {
		plan(multisession, workers = num_threads)
		if (!is.null(globals_maxsize)) options(future.globals.maxSize = globals_maxsize)
	}

	start <- Sys.time()
	if (num_threads == 1) {
		aen_results <- lapply(peak_input_list, run_aen_peaks_for_gene,
									 pseudocell_matrix = pseudocell_mat,
									 train_fraction = train_fraction,
									 lambda2 = lambda2,
									 gamma = gamma,
									 ci_cutoff = ci_cutoff,
									 pval_cutoff = pval_cutoff,
									 set_nonsig_to_zero = set_nonsig_to_zero, ...)
	} else if (!is.null(multi_seed)) {
		aen_results <- future_lapply(peak_input_list, run_aen_peaks_for_gene,
									 pseudocell_matrix = pseudocell_mat,
									 train_fraction = train_fraction,
									 lambda2 = lambda2,
									 gamma = gamma,
									 ci_cutoff = ci_cutoff,
									 pval_cutoff = pval_cutoff,
									 set_nonsig_to_zero = set_nonsig_to_zero,
									 future.seed = multi_seed, ...)
	} else {
		aen_results <- future_lapply(peak_input_list, run_aen_peaks_for_gene,
									 pseudocell_matrix = pseudocell_mat,
									 train_fraction = train_fraction,
									 lambda2 = lambda2,
									 gamma = gamma,
									 ci_cutoff = ci_cutoff,
									 pval_cutoff = pval_cutoff,
									 set_nonsig_to_zero = set_nonsig_to_zero, ...)
	}
	names(aen_results) <- names(peak_input_list)
	end <- Sys.time()
	if (verbose) print(paste0("AEN completed in ", end - start))
	plan(sequential)

	# return object
	return(aen_results)
}

#' Run adaptive elastic net to identify TFs regulating target genes
#'
#' This function will identify putative transcription factors regulating each of
#' the inputted genes. It takes as input your Seurat object, the returned value
#' of run_peak_aen, the pseudocell expression matrix generated by 
#' prepare_pseudocell_matrix, and parameters for running the adaptive
#' elastic net and parallelization. Optionally, the list of genes that you wish
#' to model can be provided if running in promoter_only mode, where non-promoter
#' CREs are ignored when searching for TF motifs to include for modeling step.
#' Genes without predicted linked CREs or any peaks within the distance 
#' specified by promoter_threshold from the gene's TSS are excluded, 
#' and names are printed if verbose is TRUE. The function returns information 
#' for each modeled gene as a list. Each gene's entry in this list is a list
#' containing the following information: the coefficient of determination 
#' calculated during the cross validation step with the calculated lambda.min value,
#' the trained model object, and a data frame with regulatory weights and standard
#' errors for all statistically significant TFs. Regulatory weights for 
#' non-significant TFs are set to 0 for future analysis if desired.
#'
#' @param seurat A Seurat object
#' @param pseudocell_mat Pseudocell expression matrix to use
#' @param aen_results_peaks Lists of modeling information returned from running run_peak_aen on list of genes of interest
#' @param gene_list Optionally names of genes to model, if not using modeled CREs and only using promoter regions
#' @param lambda2 Parameter for quadratic L2 penalty for regularization
#' @param gamma Positive constant for calculating adaptive weights
#' @param ci_cutoff Confidence interval cutoff used to determine whether an estimated non-zero coefficient should be kept
#' @param pval_cutoff As an alternative, p value cutoff to use in order to calculate ci_cutoff. E.g. p value of 0.5 corresponds to 95% CI.
#' @param set_nonsig_to_zero Boolean to determine whether non-significant coefficient estimates should be set to zero
#' @param promoter_only Boolean determining whether modeling is run on TFs with motifs present in gene promoter regions only
#' @param promoter_threshold Distance from TSS to determine promoter region to classify overlapping peaks in dataset as promoter peaks
#' @param train_fraction Fraction of pseudocells used for training during cross-validation step
#' @param num_bootstraps Number of bootstrap samples
#' @param bootstrap Boolean if set to false, will not perform bootstrapping
#' @param num_threads Number of threads to use for multithreading
#' @param globals_maxsize If running into RAM problems during multithreading, can use this parameter to set future.globals.maxSize if not done manually
#' @param verbose Boolean to determine whether to run silently
#' @param bs_seed Seed for reproducibility in determining bootstrap seeds, set to NULL if not needed
#' @param peak_assay Name of ATAC assay to use for peak information, set to "peaks" by default
#' @param multi_seed Seed for reproducibility during multithreaded model training, set to NULL if not needed
#'
#' @return list of lists per modeled gene, containing modeling and TF gene regulatory network information
#' @export
#'
run_tf_aen <- function(seurat,
                       pseudocell_mat,
                       aen_results_peaks = peak_results,
                       gene_list = NULL,
                       lambda2 = 0.5,
                       gamma = 1,
                       ci_cutoff = 1.96,
                       pval_cutoff = NULL,
                       set_nonsig_to_zero = TRUE,
                       promoter_only = FALSE,
                       promoter_threshold = 2000,
                       train_fraction = 0.8,
                       num_bootstraps = 100,
                       bootstrap = TRUE,
                       num_threads = 16,
                       globals_maxsize = NULL,
                       verbose = TRUE,
                       bs_seed = 943126,
                       peak_assay = "peaks",
                       multi_seed = 6283408, ...) {
	require(Seurat)
	require(Signac)
	require(SeuratWrappers)
	require(BiocGenerics)
	require(tidyverse)
	require(gcdnet)
	require(future)
	require(future.apply)

	modeled_genes <- names(aen_results_peaks)
	if (!is.null(gene_list) && promoter_only) {
		if (class(gene_list) == "list") {
			gene_list <- unlist(gene_list)
		}		
		modeled_genes <- gene_list
	}

	###############
  	# allow user defined ATAC assay name
  	tmp_assay = seurat[[peak_assay]]
  	peak_tf_key <- tmp_assay@motifs@data
  	colnames(peak_tf_key) <- unlist(tmp_assay@motifs@motif.names)

  	# peak_tf_key <- seurat@assays$peaks@motifs@data
	# colnames(peak_tf_key) <- unlist(seurat@assays$peaks@motifs@motif.names)
  ###############

	regulator_tf_names <- colnames(peak_tf_key)
	regulator_tf_names <- regulator_tf_names[which(regulator_tf_names %in% colnames(pseudocell_mat))]

	peak_tf_key <- peak_tf_key[, regulator_tf_names]
	peak_tf_key_tibble <- as_tibble(BiocGenerics::t(peak_tf_key), rownames = "rowname")

	# prepare initial TF-gene lists
	gene_coords <- Signac:::CollapseToLongestTranscript(Annotation(seurat))
	all_peaks <- rownames(GetAssayData(seurat, assay = peak_assay))
	prom_matrix <- UpstreamDistanceToTSS(peaks = StringToGRanges(all_peaks),
	                                      genes = gene_coords[which(gene_coords$gene_name %in% modeled_genes)],
	                                      distance = promoter_threshold)

	prom_input_list <- lapply(modeled_genes, function(x) {
							peak_col <- prom_matrix[, x]
							return(names(peak_col)[which(peak_col > 0)])
						})
	names(prom_input_list) <- modeled_genes

	#prom_input_list <- prom_input_list[which(names(prom_input_list) %in% names(peak_input_list))] # get rid of same 3 MT genes

	if (promoter_only) {
		# linked_prom_peak_list <- lapply(prom_input_list, function(x) colnames(x[[2]]))
		tf_aggregates <- lapply(prom_input_list, peaks_to_tfs, key_tibble = peak_tf_key_tibble)
		names(tf_aggregates) <- modeled_genes
		tf_aggregates <- tf_aggregates[which(unlist(lapply(tf_aggregates, length)) > 1)]
		genes_without_annotated_promoters <- modeled_genes[which(!(modeled_genes %in% names(tf_aggregates)))]
		if (verbose) print(paste0("Genes without any candidate TFs--most likely no peaks in promoter region based on threshold and provided genome annotation: ", 
								  genes_without_annotated_promoters))
	} else {
		aen_lists <- lapply(aen_results_peaks, function(x) {
				l <- x[[4]]
    			l <- as.data.frame(l)[which(l[, "coef_if_kept"] != 0), ]
    			l <- rownames(l)[which(rownames(l) != "(Intercept)")]
			})
		names(aen_lists) <- modeled_genes
		linked_peak_list <- lapply(modeled_genes, function(x) {
								union(aen_lists[[x]], prom_input_list[[x]])
							})
		names(linked_peak_list) <- modeled_genes

		tf_aggregates <- lapply(linked_peak_list, peaks_to_tfs, key_tibble = peak_tf_key_tibble)
		names(tf_aggregates) <- modeled_genes
		tf_aggregates <- tf_aggregates[which(unlist(lapply(tf_aggregates, length)) > 1)]
		genes_without_peaks <- modeled_genes[which(!(modeled_genes %in% names(tf_aggregates)))]
		if (verbose) print(paste0("Genes without any candidate TFs--most likely no linked peaks or promoter region peaks: ",
							      genes_without_peaks))
	}

	# bootstrap setup
	num_bootstraps = num_bootstraps + 1 # last seed added for cross validation step
	if (!bootstrap) num_bootstraps = 2
	if (!(is.null(bs_seed))) set.seed(bs_seed)
	bootstrap_sequence_input_lists <- make_bootstrap_sequences(num_bootstraps, gene_list)

	# run aen
	tf_aggregates <- tf_aggregates[which(unlist(lapply(tf_aggregates, length)) > 1)] 
	input_list <- lapply(names(tf_aggregates), function(x) list(x, 
                                                            tf_aggregates[[x]],
                                                            bootstrap_sequence_input_lists[[x]]))
	names(input_list) <- names(tf_aggregates)

	if (num_threads > 1) {
		plan(multisession, workers = num_threads)
		if (!is.null(globals_maxsize)) options(future.globals.maxSize = globals_maxsize)
	}
	start <- Sys.time()
	if (num_threads == 1) {
		aen_results <- lapply(input_list, run_aen_tfs_for_gene,
									 regulator_names = regulator_tf_names,
									 pseudocell_matrix = pseudocell_mat, 
									 lambda2 = lambda2,
									 train_fraction = train_fraction,
									 gamma = gamma,
									 ci_cutoff = ci_cutoff,
									 pval_cutoff = pval_cutoff,
									 set_nonsig_to_zero = set_nonsig_to_zero, ...)
	} else if (!is.null(multi_seed)) {
		aen_results <- future_lapply(input_list, run_aen_tfs_for_gene,
									 regulator_names = regulator_tf_names,
									 pseudocell_matrix = pseudocell_mat, 
									 lambda2 = lambda2,
									 train_fraction = train_fraction,
									 gamma = gamma,
									 ci_cutoff = ci_cutoff,
									 pval_cutoff = pval_cutoff,
									 set_nonsig_to_zero = set_nonsig_to_zero,
									 future.seed = multi_seed, ...)
	} else {
		aen_results <- future_lapply(input_list, run_aen_tfs_for_gene,
									 regulator_names = regulator_tf_names,
									 pseudocell_matrix = pseudocell_mat, 
									 lambda2 = lambda2,
									 train_fraction = train_fraction,
									 gamma = gamma,
									 ci_cutoff = ci_cutoff,
									 pval_cutoff = pval_cutoff,
									 set_nonsig_to_zero = set_nonsig_to_zero, ...)
	}
	names(aen_results) <- names(input_list)
	end <- Sys.time()
	if (verbose) print(paste0("AEN completed in ", end - start))
	plan(sequential)

	return(aen_results)
}

#' Function to rank TFs based on model results
#'
#' This function ranks TFs by regulatory influence in the provided
#' tf_results list. It does this by summing regulatory coefficients 
#' for each TF across all genes. By default, it weights the summed 
#' coefficients by the mean expression of the TF, following the 
#' hypothesis that highly expressed TFs are more likely to be 
#' relevant than lowly expressed TFs, so that the computed regulatory 
#' score is effectively the number of target transcripts increased by 
#' one unit of expression of the given TF. Optionally, the names of 
#' genes to weight negatively can be provided in order to weight
#' regulatory coefficients for each modeled gene. This can be helpful
#' when ranking TFs predicted to regulate a set of differentially
#' expressed genes in order to predict TFs that are associated or
#' potentially drive either side of the comparison.
#' 
#' @param tf_results List output returned by run_tf_aen with trained model information
#' @param negative_genes Genes to weight negatively if trying to associate TFs with one of two sides in a trajectory/lineage
#' @param regulator_tf_names List of TFs with motif and expression information in dataset
#' @param seurat A Seurat object
#' @param weight_by_expr Boolean to multiply estimated regulatory coefficients by mean TF expression
#' @param expr_assay Expression assay to use
#' @param slot Assay slot to use
#' @param num_cores Number of cores to use for parallelization
#'
#' @return Data frame with regulatory scores for each TF
#' @export
#'
rank_tfs <- function(tf_results,
                     seurat,
                     negative_genes = c(),
                     regulator_tf_names = NULL,					 
                     weight_by_expr = TRUE,
                     expr_assay = "SCT",
                     slot = "data",
                     num_cores = 4) {
	require(Seurat)
	require(parallel)
	require(tidyverse)
	require(Matrix)

	if (is.null(regulator_tf_names)) {
		regulator_tf_names <- unique(unlist(lapply(tf_results, function(x) rownames(x[[4]]))))
		regulator_tf_names <- regulator_tf_names[which(regulator_tf_names != "(Intercept)")]
	}

	mean_expr <- Matrix::rowSums(GetAssayData(seurat, assay = expr_assay, slot = slot)) / dim(seurat)[2]
	if (num_cores == 1) {
		tf_weights <- lapply(regulator_tf_names, function(x) {
			tf_expr <- ifelse(weight_by_expr, mean_expr[x], 1)
	   		coef_sum <- sum(unlist(lapply(tf_results, function(xx) {
		   						   		ifelse(!(x %in% rownames(xx[[4]])) || x == xx[[1]], 
		   								       0,
		   								       ifelse(xx[[1]] %in% negative_genes, -1, 1) * xx[[4]][x, "coef_if_kept"])
		   						   })))
	    	se_sum <- sqrt(sum(unlist(lapply(tf_results, function(xx) {
	    						 	   	ifelse(!(x %in% rownames(xx[[4]])) || x == xx[[1]] || xx[[4]][x, "coef_if_kept"] == 0,
	    						 	   		   0,
	    						 	   		   xx[[4]][x, "se"])
	    						 	  }))^2))
	    	return(c(x, tf_expr * coef_sum, tf_expr * se_sum))
		})
	} else {
		tf_weights <- mclapply(regulator_tf_names, function(x) {
			tf_expr <- ifelse(weight_by_expr, mean_expr[x], 1)
	   		coef_sum <- sum(unlist(lapply(tf_results, function(xx) {
		   						   		ifelse(!(x %in% rownames(xx[[4]])) || x == xx[[1]], 
		   								       0,
		   								       ifelse(xx[[1]] %in% negative_genes, -1, 1) * xx[[4]][x, "coef_if_kept"])
		   						   })))
	    	se_sum <- sqrt(sum(unlist(lapply(tf_results, function(xx) {
	    						 	   	ifelse(!(x %in% rownames(xx[[4]])) || x == xx[[1]] || xx[[4]][x, "coef_if_kept"] == 0,
	    						 	   		   0,
	    						 	   		   xx[[4]][x, "se"])
	    						 	  }))^2))
	    	return(c(x, tf_expr * coef_sum, tf_expr * se_sum))
		}, mc.cores = num_cores)
	}

	tf_weights <- t(as.data.frame(tf_weights)) %>% as.data.frame
	tf_weights[, 2] <- as.numeric(tf_weights[, 2])
	tf_weights[, 3] <- as.numeric(tf_weights[, 3])

	colnames(tf_weights) <- c("TF_name", "Score", "SE")
	tf_weights <- tf_weights[order(tf_weights$Score, decreasing = TRUE), ]
	rownames(tf_weights) <- tf_weights$TF_name

	return(tf_weights)
}

#' Function to rank TFs based on graph analysis of model results
#'
#' This function ranks TFs by centrality in the provided
#' tf_results list. It does this by constructing gene regulatory
#' networks using the estimated coefficients of each TF for
#' each gene. The function returns two rankings by centrality:
#' betweenness and PageRank. In order to prioritize TFs that are
#' central, rather than targets, for PageRank, edges are reversed.
#' 
#' @param tf_results List output returned by run_tf_aen with trained model information
#'
#' @return List of two rankings, one by betweenness and one by PageRank
#' @export
#'
rank_tfs_by_centrality <- function(tf_results, 
	                               seurat, 
	                               assay = "SCT", 
	                               slot = "data") {
	require(igraph)
	require(tidyverse)
	require(Matrix)

	mean_expr <- Matrix::rowSums(GetAssayData(seurat, assay = "SCT", slot = "data")) / dim(seurat)[2]
	edge_df <- lapply(tf_results, function(x) {
                    coef_df <- x[[4]]
                    start <- rownames(coef_df)[which(coef_df[, "coef_if_kept"] != 0)]
                    start <- start[which(start != "(Intercept)")]
                    target <- rep(x[[1]], length(start))
                    coef <- coef_df[start, "coef_if_kept"]
                    abscoef <- abs(coef)
                    coefmean <- coef * mean_expr[start]
                    abscoefmean <- abs(coefmean)
                    return(data.frame(start = start, target = target, abscoef = abscoef))  
                })
	edge_df <- edge_df %>% bind_rows() %>% as.data.frame

	graph_tf <- graph_from_data_frame(edge_df[, c("start", "target", "abscoef")], directed = TRUE)
	# reverse order to prioritize central TFs rather than target genes
	graph_centrality <- graph_from_data_frame(edge_df[, c("target", "start", "abscoef")], directed = TRUE)

	betweenness_values <- betweenness(graph_tf)
	names(betweenness_values) <- names(V(graph_tf))
	pagerank_values <- page_rank(graph_centrality)[[1]]

	betweenness_values <- sort(betweenness_values, decreasing = TRUE)
	pagerank_values <- sort(pagerank_values, decreasing = TRUE)

	results <- list(betweenness_values, pagerank_values)
	names(results) <- c("Betweenness", "PageRank")

	return(results)
}

#' Run adaptive elastic net to identify CREs regulating an individual gene
#'
#' This function will identify putative cis-regulatory elements regulating a 
#' target gene. It takes as input an input list, containing potential 
#' regulatory CREs, recommended to be determined by distance from gene TSS,
#' the pseudocell expression matrix generated by prepare_pseudocell_matrix, 
#' and parameters for running the adaptive elastic net. The function
#' first performs a cross-validation step to calculate the optimal lambda as
#' well as adaptive L1 penalty weights. Then,the adaptive elastic net 
#' step is performed with bootstrapping to determine regulatory coefficients.
#' Information is returned for the modeled gene as a list, containing
#' the following information: the coefficient of determination calculated
#' during the cross validation step with the calculated lambda value, 
#' the trained model object, and a data frame with regulatory weights
#' and standard errors for all statistically significant TFs. Regulatory 
#' weights for non-significant TFs are set to 0 for future analysis if 
#' desired.
#'
#' @param input_tf_list List containing gene name, putative regulatory CREs to consider, and bootstrap seeds
#' @param pseudocell_matrix Pseudocell chromatin accessibility matrix to use
#' @param train_fraction Fraction of pseudocells used for training during cross-validation step
#' @param set_seed Boolean to determine whether to set seeds with inputted bootstrap seeds
#' @param lambda Can be lambda.min, or will be lambda.1se otherwise. During cross-validation step, determines whether to select the optimal value of lambda that gives the smallest cross validation error (lambda.min) or the largest lambda value such that the error is within 1 standard error of the minimum error (lambda.1se)
#' @param lambda2 Parameter for quadratic L2 penalty for regularization
#' @param gamma Positive constant for calculating adaptive weights
#' @param ci_cutoff Confidence interval cutoff used to determine whether an estimated non-zero coefficient should be kept
#' @param pval_cutoff As an alternative, p value cutoff to use in order to calculate ci_cutoff. E.g. p value of 0.5 corresponds to 95% CI
#' @param set_nonsig_to_zero Boolean to determine whether non-significant coefficient estimates should be set to zero
#' @param recalculate_l1 Boolean to determine whether to recalculate adaptive L1 penalty weights with each bootstrapped sample. Set to FALSE by default to reduce runtime
#'
#' @return List containing gene name, coefficient of determination, trained model, and coefficient data frame
#' @export
#'
run_aen_peaks_for_gene <- function(input_list,
                                   pseudocell_matrix,
                            	   train_fraction = 0.8,
                            	   set_seed = TRUE,
                            	   lambda = "lambda.min",
                            	   lambda2 = 0.5,
                            	   gamma = 1,
                            	   ci_cutoff = 1.96,
                            	   pval_cutoff = NULL,
                            	   set_nonsig_to_zero = TRUE,
                            	   recalculate_l1 = FALSE, ...) {
    require(gcdnet)

    target_name <- input_list[[1]]
    pseudocell_factor_expressions <- input_list[[2]]
    num_pseudo_cells <- dim(pseudocell_factor_expressions)[1]

    bootstrap_seeds <- input_list[[3]]
    if (set_seed && !is.null(bootstrap_seeds)) { 
        set.seed(bootstrap_seeds[length(bootstrap_seeds)])
    }

    train_rows <- sample(nrow(pseudocell_matrix), train_fraction*nrow(pseudocell_matrix))
    x.train <- as.matrix(pseudocell_factor_expressions[train_rows, ])
    x.test <- as.matrix(pseudocell_factor_expressions[-train_rows, ])

    y.train <- as.numeric(pseudocell_matrix[train_rows, target_name])
    y.test <- as.numeric(pseudocell_matrix[-train_rows, target_name])

    # run elastic net to determine weights for adaptive penalty
    aen.fit <- cv.gcdnet(x.train, y.train,
    					 method = "ls",
    					 standardize = TRUE,
    					 intercept = TRUE,
    					 pred.loss = "loss",
                         lambda2 = lambda2, ...)
    # add pseudocount for computational purposes, so 0s don't get turned to infinity for next step
    weights = 1 / (abs(coef(aen.fit)[-1, ])^gamma + 1/num_pseudo_cells)

    # adaptive elastic net, cross validation to determine lambda.min or lambda.1se
    aen.fit <- cv.gcdnet(x.train, y.train,
    					 method = "ls",
    					 standardize = TRUE,
    					 intercept = TRUE,
    					 pred.loss = "loss",
                         lambda2 = lambda2,
                         pf = weights, ...)

    # calculate r^2 with predicted vs actual expression
    aen.predicted <- predict(aen.fit, s = lambda, newx = x.test)
    MSE <- 1 / num_pseudo_cells * sum((y.test - aen.predicted)^2)
    TSS <- sum((y.test - mean(y.test))^2)
    r2 <- 1 - num_pseudo_cells * MSE / TSS

    num_bootstraps <- max(1, length(bootstrap_seeds) - 1)
    coef_df <- matrix(nrow = length(rownames(coef(aen.fit))),
    				  ncol = num_bootstraps)
    rownames(coef_df) <- rownames(coef(aen.fit))

    # bootstrapping to estimate variance of coefficient estimates
    for (i in 1:num_bootstraps) {
        if (set_seed && !is.null(bootstrap_seeds)) set.seed(bootstrap_seeds[i])
        bs_rows <- sample(nrow(pseudocell_matrix), nrow(pseudocell_matrix), replace = TRUE)
        x <- as.matrix(pseudocell_factor_expressions[bs_rows, ])
        y <- as.matrix(pseudocell_matrix[bs_rows, target_name])

        lambda_to_use = ifelse(lambda == "lambda.min", aen.fit$lambda.min, aen.fit$lambda.1se)

 		if (recalculate_l1) {
        	bs.aen <- gcdnet(x, y,
        				 method = "ls",
        				 standardize = TRUE,
        				 intercept = TRUE,
                         lambda2 = lambda2,
                         lambda = lambda_to_use, ...)
        	weights = 1 / (abs(coef(aen.fit)[-1, ])^gamma + 1/num_pseudo_cells) 
        }

        bs.aen <- gcdnet(x, y,
        				 method = "ls",
        				 standardize = TRUE,
        				 intercept = TRUE,
                         lambda2 = lambda2,
                         pf = weights,
                         lambda = lambda_to_use, ...)
        coef_df[, i] <- coef(bs.aen)[rownames(coef_df), ]
    }

    if (set_nonsig_to_zero && is.null(ci_cutoff)) {
    	ci_cutoff <- qnorm(1 - pval_cutoff / 2, 0, 1)
    }

    coefs <- apply(coef_df, 1, function(x) {
                coef_mean <- mean(x)
                if (length(x) > 1 && num_bootstraps > 1) {
                	standard_error <- sqrt(1/(length(x) - 1) * sum((x - coef_mean)^2))
                	se_cutoff <- ci_cutoff * standard_error
                } else {
                	standard_error <- NA
                	se_cutoff <- 0
                }
                if (set_nonsig_to_zero) {
                	c(ifelse(abs(coef_mean) > se_cutoff, coef_mean, 0),
                		 coef_mean,
                		 standard_error) # set coefficient for that peak to 0 if 95% confidence interval overlaps with 0
                } else {
                	c(coef_mean, coef_mean, standard_error)
                }
             }, simplify = TRUE)
    rownames(coefs) <- c("coef_if_kept", "coef_mean", "se")

    results <- list(target_name, r2, aen.fit, t(coefs))
    names(results) <- c("gene", "r2", "aen.fit", "coefs")

    return(results)
}

#' Run adaptive elastic net to identify TFs regulating an individual gene
#'
#' This function will identify putative transcription factors regulating a 
#' target gene. It takes as input an input list, containing potential 
#' regulatory TFs, recommended to be determined by motif information,
#' the pseudocell expression matrix generated by prepare_pseudocell_matrix,
#' and parameters for running the adaptive elastic net. The function
#' first performs a cross-validation step to calculate the optimal lambda as 
#' well as adaptive L1 penalty weights. Then the adaptive elastic net
#' step is performed with bootstrapping to determine regulatory coefficients.
#' Information is returned for the modeled gene as a list, containing
#' the following information: the coefficient of determination calculated
#' during the cross validation step with the calculated lambda value,
#' the trained model object, and a data frame with regulatory weights 
#' and standard errors for all statistically significant TFs. Regulatory
#' weights for non-significant TFs are set to 0 for future analysis if
#' desired.
#'
#' @param input_tf_list List containing gene name, putative regulatory TFs to consider, and bootstrap seeds
#' @param pseudocell_matrix Pseudocell expression matrix to use
#' @param regulator_names Optionally, list of TF names to model. TFs that are not within this list, if not NULL, are excluded
#' @param train_fraction Fraction of pseudocells used for training during cross-validation step
#' @param set_seed Boolean to determine whether to set seeds with inputted bootstrap seeds
#' @param lambda Can be lambda.min, or will be lambda.1se otherwise. During cross-validation step, determines whether to select the optimal value of lambda that gives the smallest cross validation error (lambda.min) or the largest lambda value such that the error is within 1 standard error of the minimum error (lambda.1se)
#' @param lambda2 Parameter for quadratic L2 penalty for regularization
#' @param gamma Positive constant for calculating adaptive weights
#' @param ci_cutoff Confidence interval cutoff used to determine whether an estimated non-zero coefficient should be kept
#' @param pval_cutoff As an alternative, p value cutoff to use in order to calculate ci_cutoff. E.g. p value of 0.5 corresponds to 95% CI
#' @param set_nonsig_to_zero Boolean to determine whether non-significant coefficient estimates should be set to zero
#' @param recalculate_l1 Boolean to determine whether to recalculate adaptive L1 penalty weights with each bootstrapped sample. Set to FALSE by default to reduce runtime
#' 
#' @return List containing gene name, coefficient of determination, trained model, and coefficient data frame
#' @export
#'
run_aen_tfs_for_gene <- function(input_tf_list,
								 pseudocell_matrix,
								 regulator_names,
                          		 train_fraction = 0.8,
                          		 set_seed = TRUE,
                          		 lambda = "lambda.min",
                          		 lambda2 = 0.5,
                          		 gamma = 1,
                            	 ci_cutoff = 1.96,
                            	 pval_cutoff = NULL,
                            	 set_nonsig_to_zero = TRUE,
                            	 recalculate_l1 = FALSE, ...) {
	require(gcdnet)

    target_name <- input_tf_list[[1]]
    tf_agg <- input_tf_list[[2]]
    names(tf_agg) <- tf_agg

    # remove TFs with no expression data or that are not within provided list of TFs to include
    if (is.null(regulator_names)) {
    	tf_agg <- tf_agg[which(tf_agg %in% colnames(pseudocell_matrix))]
    } else {
    	tf_agg <- tf_agg[which(tf_agg %in% regulator_names)] 
    }

    num_pseudo_cells <- dim(pseudocell_matrix)[1]

    bootstrap_seeds <- input_tf_list[[3]]
    if (set_seed && !is.null(bootstrap_seeds)) {
        set.seed(bootstrap_seeds[length(bootstrap_seeds)])
    }

    pseudocell_factor_expressions <- pseudocell_matrix[, tf_agg]
    colnames(pseudocell_factor_expressions) <- tf_agg
    
    # removing target gene if TF from factors, otherwise correlation will be with itself
    if (target_name %in% tf_agg) {
        pseudocell_factor_expressions <- pseudocell_factor_expressions[, (names(pseudocell_factor_expressions) != target_name)] # force training on other TFs (lose out on autoregulation)
    }

    train_rows = sample(nrow(pseudocell_matrix), train_fraction*nrow(pseudocell_matrix))
    x.train = as.matrix(pseudocell_factor_expressions[train_rows, ])
    x.test = as.matrix(pseudocell_factor_expressions[-train_rows, ])

    y.train = as.numeric(pseudocell_matrix[train_rows, target_name])
    y.test = as.numeric(pseudocell_matrix[-train_rows, target_name])

	# run elastic net to determine weights for adaptive penalty
    aen.fit <- cv.gcdnet(x.train, y.train,
    					 method = "ls",
    					 standardize = TRUE,
    					 intercept = TRUE,
    					 pred.loss = "loss",
                         lambda2 = lambda2, ...)

    # add pseudocount for computational purposes, so 0s don't get turned to infinity for next step
    weights = 1 / (abs(coef(aen.fit)[-1, ])^gamma + 1/num_pseudo_cells) 

    # adaptive elastic net, cross validation to determine lambda.min or lambda.1se
    aen.fit <- cv.gcdnet(x.train, y.train, 
    					 method = "ls",
    					 standardize = TRUE,
    					 intercept = TRUE,
    					 pred.loss = "loss",
                         lambda2 = lambda2,
                         pf = weights, ...)
    
    # calculate r^2 with predicted vs actual expression
    aen.predicted <- predict(aen.fit, s = lambda, newx = x.test)
    MSE <- 1 / num_pseudo_cells * sum((y.test - aen.predicted)^2)
    TSS <- sum((y.test - mean(y.test))^2)
    r2 <- 1 - num_pseudo_cells * MSE / TSS

    num_bootstraps <- max(1, length(bootstrap_seeds) - 1)
    coef_df <- matrix(nrow = length(rownames(coef(aen.fit))),
    				  ncol = num_bootstraps)
    rownames(coef_df) <- rownames(coef(aen.fit))
    
    # bootstrapping to estimate variance of coefficient estimates
    for (i in 1:num_bootstraps) {
        if (set_seed && !is.null(bootstrap_seeds)) set.seed(bootstrap_seeds[i])
        bs_rows <- sample(nrow(pseudocell_matrix), nrow(pseudocell_matrix), replace = TRUE)
        x <- as.matrix(pseudocell_factor_expressions[bs_rows, ])
        y <- as.matrix(pseudocell_matrix[bs_rows, target_name])
        
        lambda_to_use = ifelse(lambda == "lambda.min", aen.fit$lambda.min, aen.fit$lambda.1se)

        if (recalculate_l1) {
        	bs.aen <- gcdnet(x, y,
        				 method = "ls",
        				 standardize = TRUE,
        				 intercept = TRUE,
                         lambda2 = lambda2,
                         lambda = lambda_to_use, ...)
        	weights = 1 / (abs(coef(aen.fit)[-1, ])^gamma + 1/num_pseudo_cells) 
        }

        bs.aen <- gcdnet(x, y,
        				 method = "ls",
        				 standardize = TRUE,
        				 intercept = TRUE,
                         lambda2 = lambda2,
                         pf = weights,
                         lambda = lambda_to_use, ...)
        coef_df[, i] <- coef(bs.aen)[rownames(coef_df), ]
    }
    
    if (set_nonsig_to_zero && is.null(ci_cutoff)) {
    	ci_cutoff <- qnorm(1 - pval_cutoff / 2, 0, 1)
    }

    coefs <- apply(coef_df, 1, function(x) {
                coef_mean <- mean(x)
                if (length(x) > 1 && num_bootstraps > 1) {
                    standard_error <- sqrt(1/(length(x) - 1) * sum((x - coef_mean)^2))
                    se_cutoff <- ci_cutoff * standard_error
                } else {
                	standard_error <- NA
                	se_cutoff <- 0
                } 
                if (set_nonsig_to_zero) {
                	c(ifelse(abs(coef_mean) > se_cutoff, coef_mean, 0),
                		 coef_mean,
                		 standard_error) # set coefficient for that peak to 0 if 95% confidence interval overlaps with 0
                } else {
                	c(coef_mean, coef_mean, standard_error)
                }
            }, simplify = TRUE)
    rownames(coefs) <- c("coef_if_kept", "coef_mean", "se")
    
    results <- list(target_name, r2, aen.fit, t(coefs))
    names(results) <- c("gene", "r2", "aen.fit", "coefs")

    return(results)
}

#' Utility function used to convert a peak list for a given gene to a list of TFs with predicted motifs within the peak list
#'
#' This function takes in a peak list and peak-TF key as input and
#' returns the TF names with at least one motif present in the 
#' peak list, as determined by the peak-TF key.
#' 
#' @param peak_list Vector of peak names
#' @param key_tibble Tibble of peaks by motifs denoting presence of each motif in each peak
#'
#' @return Names of TFs with motifs within inputted peaks
#' @export
#'
peaks_to_tfs <- function(peak_list, key_tibble) {
    require(tidyverse)

    if (length(peak_list) == 1 && peak_list == "") {
        return("")
    }
    subset_tibble <- key_tibble[, c("rowname", peak_list)]
    subset <- subset_tibble %>% select(-rowname) %>% rowSums
    subset <- which(subset > 0)
    
    return(subset_tibble$rowname[subset])
}

#' Utility function that extracts names of peaks with predicted non-zero regulatory effect
#'
#' This function takes in the output of run_peak_aen and returns
#' names of predicted CREs, by non-zero regulatory effect, for each
#' modeled gene.
#' 
#' @param peak_results Output of run_peak_aen, in list of lists format
#'
#' @return List of character vectors, corresponding to predicted CRE names for each modeled gene
#' @export
#'
make_aen_lists <- function(peak_results) {
	lapply(peak_results, function(x) {
		l <- x[[4]]
		l <- as.data.frame(l)[which(l[, "coef_if_kept"] != 0), ]
		l <- rownames(l)[which(rownames(l) != "(Intercept)")]
	})
}

#' Utility function to convert list of lists run_aen_tf output to data frame
#'
#' This function extracts predicted non-zero regulatory interactions
#' between TFs and genes from the output of run_aen_tf, and stores
#' the information in a data frame.
#' 
#' @param tf_results Output of run_tf_aen, in list of lists format
#' 
#' @return Data frame of regulatory interactions, with TFs by row and modeled genes by column
#' @export
#'
make_model_df <- function(tf_results) {
	aen_model <- lapply(tf_results, function(x) x[[4]][union(1, which(x[[4]][, "coef_if_kept"] != 0)), "coef_if_kept"])
	aen_model <- aen_model[which(unlist(lapply(aen_model, length)) > 1)] # none
	aen_model <- bind_rows(aen_model)
	aen_model[is.na(aen_model)] <- 0
	aen_model <- aen_model %>% as.data.frame %>% as.matrix
	rownames(aen_model) <- names(tf_results)

	return(aen_model)
}

#' Utility function taken from Signac DistanceToTSS function, for considering only upstream promoter region for peaks
#' 
#' This function is a copy of the Signac DistanceToTSS function, except for
#' changing the downstream parameter in the Extend function call from distance
#' to 0.
#' 
UpstreamDistanceToTSS <- function(peaks,
								  genes,
								  distance = 200000,
								  sep = c("-", "-")
								  ) {
  require(Matrix)
  require(GenomicRanges)

  tss <- resize(x = genes, width = 1, fix = 'start')
  genes.extended <- suppressWarnings(
    expr = Extend(
      x = tss, upstream = distance, downstream = 0
    )
  )
  overlaps <- findOverlaps(
    query = peaks,
    subject = genes.extended,
    type = 'any',
    select = 'all'
  )
  hit_matrix <- sparseMatrix(
    i = queryHits(x = overlaps),
    j = subjectHits(x = overlaps),
    x = 1,
    dims = c(length(x = peaks), length(x = genes.extended))
  )
  rownames(x = hit_matrix) <- GRangesToString(grange = peaks, sep = sep)
  colnames(x = hit_matrix) <- genes.extended$gene_name
  return(hit_matrix)
}
